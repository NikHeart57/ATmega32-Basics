.DEVICE		ATmega32		; Директива ".DEVICE - определение устройства для которого пишется код"					
							; Директива ".INCLUDE" - подключение заголовочных файлов
.INCLUDE	"m32def.inc"		; Подключен заголовочный файл в котором хранятся адреса и символические имена регистров (типа: PORTA, DDRA, TIMSK и т.д.)											
							; Директива ".DEF" - Присвоение символического имени регистру		
.DEF		temp1 = r16			; Присвоение символического имени регистру r16 
.DEF		temp2 = r17			; Присвоение символического имени регистру r17
.DEF		temp3 = r18			; Присвоение символического имени регистру r18
.DEF		temp4 = r19			; Присвоение символического имени регистру r18
.DEF		null = r25			; Присвоение символического имени регистру r25	*Для справки: у AtMega32 регистры общего назначения - r16-r25								
							; Директива ".DSEG" - Начало сегмента данных
.DSEG							; Директива ".BYTE" - резервирует байты в ОЗУ (доступны адреса: $0060 - $085F)
.ORG		$0060				; Директива .ORG устанавливает счётчик положения равным заданной величине, которая передаётся как параметр
Second:		.BYTE 1				; зарезервирован 1 байт для Second по адресу	$0060
.ORG		$0061
Minute:		.BYTE 1				; зарезервирован 1 байт для Minute по адресу	$0061
.ORG		$0062
Hour:		.BYTE 1				; зарезервирован 1 байт для Hour по адресу		$0062

.CSEG						; Директива ".CSEG" - Начало програмного сегмента (кода)
.ORG		$000				; Директива ".ORG" - Начальное значение для адресации. // Адрес вектора прерывания Reset (Вектор номер - 1, адрес - $000, название - RESET, символическое имя - RESET)
	JMP		RESET				; (Обязательно JMP(RJMP - все ломает) Данная команда будет размещена по адресу $000 
.ORG		$008				; Адрес вектора прерывания TIM2_COMP - (Вектор номер - 5, адрес - $008, название - TIMER2 COMP символическое имя - TIM2_COMP)
	JMP		TIM2_COMP			; (Обязательно JMP(RJMP - все ломает) Данная команда будет размещена по адресу $008
.ORG		$00E				; Адрес вектора прерывания TIM1_COMPA - (Вектор номер - 8, адрес - $00E, название - TIMER1 COMPA, символическое имя - TIM1_COMPA)
	JMP		TIM1_COMPA			; (Обязательно JMP(RJMP - все ломает) Данная команда будет размещена по адресу $014
.ORG		INT_VECTORS_SIZE    ; Конец таблицы прерываний

RESET:						; Метка RESET // Начало кода вектора RESET
	; Стек
	LDI		temp1,	Low(RAMEND)	; Инициализация стека - Обязательно!!!
	OUT		SPL,	temp1		; Инициализация стека..
	LDI		temp1,	High(RAMEND); Инициализация стека..
	OUT		SPH,	temp1		; Инициализация стека

	; Порты I/O
	LDI		temp1,	0b00111111	; Запись числа в регистр temp1 (r16)	*(1 - выход, 0 - вход)
	OUT		DDRC,	temp1		; Отправка значения temp1 в регистр DDRC
	LDI		temp1,	0b00001000	
	OUT		DDRB,	temp1

	; Разрешение прерываний для таймеров 2 и 1 по совпадению
	LDI		temp1,	(1 << OCIE2)|(0 << TOIE2)|(0 << TICIE1)|(1 << OCIE1A)|(0 << OCIE1B)|(0 << TOIE1)|(0 << OCIE0)|(0 << TOIE0) ; OCIE2 OCIE1A - 11 - прерывания разрешены
	OUT		TIMSK,	temp1
	SEI							; Разрешение прерываний

	; Таймер 2 - Динамическая индикация
	LDI		temp1,	119			; Число по которому вызовется прерывание
	OUT		OCR2,	temp1
	LDI		temp1,	(0 << FOC2)|(1 << WGM21)|(0 <<  WGM20)|(0 << COM21)|(0 << COM20)|(1 << CS22)|(1 << CS21)|(0 << CS20) ; COM - 00, пины отключены; WGM - 10 - CTC; CS - 110 - преселер 256
	OUT		TCCR2,	temp1

	; Таймер 1 - Часы
	LDI		temp1,	High(14398)	; Запись старшего байта 7199 || 14398
	LDI		temp2,	Low(14398)	; Запись младшего байта
	OUT		OCR1AH,	temp1		; OCR1AH[15:8]	- Запись надо проводить как тут - одновременно, сначала H, потом L. Запись значения прерывания CTC производится до инициализации таймера
	OUT		OCR1AL,	temp2		; OCR1AL[7:0]
	LDI		temp1,	(0 << COM1A1)|(0 << COM1A0)|(0 << COM1B1)|(0 << COM1B0)|(0 << FOC1A)|(0 << FOC1B)|(0 << WGM11)|(0 << WGM10) ; COM - порты, FOC - ?, WGM - режим CTC, CS - прескелер
	OUT		TCCR1A,	temp1
	LDI		temp1,	(0 <<  ICNC1)|(0 <<  ICES1)|(0 <<  WGM13)|(1 <<  WGM12)|(1 <<  CS12)|(0 <<  CS11)|(1 <<  CS10) ; IC - настройки пина ICP1 (PD6)
	OUT		TCCR1B,	temp1

	; Таймер 0 - PWM
	LDI		temp1,	250			; | 248 -> 97.1% | 249 -> 97.5% | 250 -> 97.9% | 251 -> 98.3% | 252 -> 98.7%  | *по расчету надо 97,5 - 98,6%
	OUT		OCR0,	temp1		; Значение сравнения f = fcpu/(N*256) = 7372800/256 = 28800 || = 14745600/256 = 57600
	LDI		temp1,	(0 << FOC0) |(1  << WGM01)|(1 << WGM00)|(1 << COM01)|(0 << COM00)|(0 << CS02)|(0 << CS01)|(1 << CS00) ; WGM - fast PWM, COM - clear on compare, CS - прескелер, FOC - ?
	OUT		TCCR0,	temp1

	LDI		null,		0		; инициализация регистра null(r25)
	STS		Second,		null	; обнуление Second
	STS		Minute,		null	; обнуление Minute
	STS		Hour,		null	; обнуление	Hour
	CLR		temp1				; Очистка регистра temp1
	CLR		temp2				; Очистка регистра temp2
	JMP		Start				; Переход в программу


	; Програмулина
Start:						; Начало кода программы
	//LDS		temp1, Second		; Пересылка из I/O-регистра в регистр (60 = 0b 0011 1100; 24 = 0b 0001 1000)
	//OUT		PORTC, temp1
	NOP
	NOP
	NOP
	NOP
	NOP
	JMP		Start				; Относительный переход (Повтор Start)


	; Подпрограмма таймера 2 - Динамическая индикация
TIM2_COMP:
	CLI							; Запрещаем прерывания, чтобы больше никакое прерывание не вклинилось
	PUSH	temp1				; Поместить значение регистра в стек
	PUSH	temp3				; Поместить значение регистра в стек
	IN		temp1,	SREG		; Загрузить из пространства ввода/вывода (порты, таймеры, конфигурационные регистры и т.д.) в регистр общего назначения
	PUSH	temp1				; Поместить значение регистра в стек

	IN		temp3, PORTC
	INC		temp3
	OUT		PORTC, temp3

	POP		temp1				; Извлечь значение регистра из стека
	OUT		SREG,	temp1		; Вывод в пространство ввода/вывода
	POP		temp3				; Извлечь значение регистра из стека
	POP		temp1				; Извлечь значение регистра из стека
	SEI							; Разрешение прерываний
	RETI


	; Подпрограмма таймера 1 - Часы
TIM1_COMPA:					; Код вектора прерываний 
	CLI							; Запрещаем прерывания, чтобы больше никакое прерывание не вклинилось
	PUSH	temp1				; Поместить значение регистра в стек
	IN		temp1,	SREG		; Загрузить из пространства ввода/вывода (порты, таймеры, конфигурационные регистры и т.д.) в регистр общего назначения
	PUSH	temp1				; Поместить значение регистра в стек
INC_Second:	
	LDS		temp1,	Second	; Пересылка из I/O-регистра в регистр
	INC		temp1				; Инкремент
	CPI		temp1, 60			; если temp1 >= 60	
	BRSH	INC_Minute
	STS		Second, temp1	; Прямое сохранение (в ОЗУ)
	INC_Minute_Ret:				; Работа с PORTC в подпрограмме(ах)
	POP		temp1				; Извлечь значение регистра из стека
	OUT		SREG,	temp1		; Вывод в пространство ввода/вывода
	POP		temp1				; Извлечь значение регистра из стека
	SEI							; Разрешение прерываний
	RETI						; Возврат из прерывания

INC_Minute:
	STS		Second, null		; обнуление Second
	LDS		temp2,	Minute		; выгрузка Minute
	INC		temp2				; инкремент Minute
	CPI		temp2, 60			; сравнение Minute и 60
	BRSH	INC_Hour
	STS		Minute, temp2		; загрузка Minute (< 60)
	INC_Hour_Ret:
	JMP		INC_Minute_Ret

INC_Hour:
	STS		Minute, null		; обнуление Minute
	LDS		temp3,	Hour		; выгрузка Hour
	INC		temp3				; инкремент Hour
	CPI		temp3, 24			; сравнение Hour и 24
	BRSH	Null_Hour
	STS		Hour, temp3			; загрузка Hour (< 24)
	Null_Hour_Ret:
	JMP		INC_Hour_Ret

Null_Hour:
	STS		Hour, null
	JMP		Null_Hour_Ret
