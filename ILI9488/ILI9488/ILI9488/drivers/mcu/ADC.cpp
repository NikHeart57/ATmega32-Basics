#include "ADC.h"

//////////////////////////////////////////////////////////////////////////
//  ПРОВЕРКА ПОДДЕРЖКИ МИКРОКОНТРОЛЛЕРА (ATmega32 ONLY)
//////////////////////////////////////////////////////////////////////////

#ifndef __AVR_ATmega32__
	#error "ADC driver requires ATmega32 MCU! Check your target device."
#endif

//////////////////////////////////////////////////////////////////////////
//  ОСНОВНЫЕ ФУНКЦИИ ИНИЦИАЛИЗАЦИИ
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Полная инициализация АЦП
 * @param state Состояние (вкл/выкл)
 * @param ref Источник опорного напряжения
 * @param prescaler Делитель частоты
 * @param channel Аналоговый канал
 * @param align Выравнивание результата
 * 
 * @details Алгоритм работы:
 * 1. Настройка управления АЦП (ADCSRA)
 * 2. Конфигурация мультиплексора и ИОН (ADMUX)
 * 3. Задержка стабилизации для внутреннего ИОН
 */
void ADC_Init(ADC_State state, ADC_Reference ref, ADC_Prescaler prescaler, 
             ADC_Channel channel, ADC_Alignment align)
{
    // 1. Конфигурация управления АЦП
    ADCSRA = (state == ADC_ENABLED) ? (1 << ADEN) | prescaler : 0;
    
    // 2. Настройка мультиплексора и опорного напряжения
    ADMUX = ref | align | (channel & 0x07);
    
    // 3. Задержка стабилизации внутреннего ИОН 2.56В
    if(ref == ADC_REF_INTERNAL) 
    {
        _delay_us(120);  // Согласно datasheet ATmega32 (раздел 24.5)
    }
}

/**
 * @brief Базовая инициализация (только вкл/выкл)
 * @param state Состояние ADC_DISABLED/ADC_ENABLED
 */
void ADC_Init(ADC_State state) 
{
    if(state == ADC_ENABLED) 
    {
        ADCSRA |= (1 << ADEN);  // Установка бита включения
    } 
    else 
    {
        ADCSRA &= ~(1 << ADEN); // Сброс бита включения
    }
}

//////////////////////////////////////////////////////////////////////////
//  ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Включение АЦП (аналог ADC_Init(ADC_ENABLED))
 */
void ADC_Enable(void) 
{
    ADCSRA |= (1 << ADEN);
}

/**
 * @brief Отключение АЦП (режим пониженного энергопотребления)
 */
void ADC_Disable(void) 
{
    ADCSRA &= ~(1 << ADEN);
}

//////////////////////////////////////////////////////////////////////////
//  ФУНКЦИИ РАБОТЫ С ПРЕОБРАЗОВАТЕЛЕМ
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Запуск преобразования
 * @details:
 * 1. Ожидает завершения предыдущего преобразования
 * 2. Устанавливает бит запуска преобразования
 */
void ADC_StartConversion(void) 
{
    while (ADCSRA & (1 << ADSC));  // Ожидание готовности АЦП
    ADCSRA |= (1 << ADSC);         // Запуск нового преобразования
}

/**
 * @brief Получение результата преобразования
 * @return 10-битное значение АЦП (0-1023)
 * @note Блокирующая функция - ожидает завершения преобразования
 */
uint16_t ADC_GetResult(void) 
{
    while (!(ADCSRA & (1 << ADIF))); // Ожидание флага завершения
    ADCSRA |= (1 << ADIF);           // Сброс флага
    return ADC;                      // Чтение результата
}

/**
 * @brief Чтение значения с указанного канала
 * @param ch Номер аналогового канала (0-7)
 * @return 10-битное значение АЦП
 * @note Автоматически запускает и ожидает преобразование
 */
uint16_t ADC_Read(ADC_Channel ch) 
{
    ADMUX = (ADMUX & ~0x07) | (ch & 0x07);  // Выбор канала
    ADC_StartConversion();                   // Запуск преобразования
    return ADC_GetResult();                  // Возврат результата
}