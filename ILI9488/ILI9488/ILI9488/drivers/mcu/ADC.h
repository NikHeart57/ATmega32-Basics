/**
 * @note        Комментарий сгенерирован нейросетью deepseek 18.08.25
 *
 * @file        ADC.h
 * @brief       Реализация драйвера АЦП для AVR микроконтроллера AtMega32
 * @details     Предоставляет базовые функции работы с аналого-цифровым преобразователем.
 *              Данная версия использовалась только для отключения АЦП на старте работы МК. 
 *				Работоспособность функций АЦП неизвестна!
 *
 * @note        Особенности:
 *              - Поддержка 8 каналов АЦП (ADC0-ADC7)
 *              - Настройка опорного напряжения (AREF/AVCC/2.56В)
 *              - Программируемый делитель частоты (2-128)
 *              - Автоматическая задержка при использовании внутреннего ИОН
 *
 * @warning     Данная версия использовалась только для отключения АЦП на старте работы МК.
 *				Работоспособность функций АЦП неизвестна!
 *
 * @attention   Для работы необходимо:
 *              - Подключение <avr/io.h> и <util/delay.h>
 *              - Корректная настройка частоты CPU (F_CPU)
 *              - Правильное подключение аналоговых входов
 *
 * @todo        Планируемые улучшения:
 *              - Добавление режима непрерывного преобразования
 *              - Поддержка дифференциального входа
 *              - Реализация калибровки АЦП
 *
 * @bug         Известные проблемы:
 *              - При быстром последовательном опросе каналов возможны искажения
 *              - Не тестировалось на максимальной частоте дискретизации
 *
 * @author      Николай Куркин, deepseek
 * @date        2025-08-18
 * @version     0.0
 *
 * @copyright   MIT License
 *
 * @example Примеры использования АЦП
 * 
 * //=== Базовый пример: однократное чтение ===//
 * 
 * // 1. Инициализация АЦП:
 * // - Включен
 * // - Внутренний ИОН 2.56В (для точных измерений)
 * // - Делитель 128 (частота ~125 кГц при F_CPU=16 МГц)
 * // - Канал 0 (PA0)
 * // - Правое выравнивание результата
 * ADC_Init(ADC_ENABLED, ADC_REF_INTERNAL, ADC_DIV128, ADC_CH0, ADC_ALIGN_RIGHT);
 * 
 * // 2. Чтение значения (с автоматическим запуском преобразования)
 * uint16_t adc_value = ADC_Read(ADC_CH0);
 * 
 * //=== Продвинутый пример: цикл измерений ===//
 * 
 * // 1. Инициализация (только включение)
 * ADC_Init(ADC_ENABLED);
 * 
 * // 2. Настройка параметров
 * ADMUX = ADC_REF_INTERNAL | ADC_ALIGN_RIGHT | ADC_CH0;
 * ADCSRA = (1 << ADEN) | ADC_DIV128;
 * 
 * // 3. Цикл измерений с ручным управлением
 * while(1) {
 *     ADC_StartConversion();          // Запуск преобразования
 *     while(!(ADCSRA & (1<<ADIF)));  // Ожидание завершения
 *     adc_value = ADC_GetResult();    // Чтение результата
 *     
 *     _delay_ms(100);                // Пауза между измерениями
 * }
 * 
 * //=== Быстрое чтение нескольких каналов ===//
 * 
 * // 1. Инициализация для канала 0
 * ADC_Init(ADC_ENABLED, ADC_REF_AVCC, ADC_DIV64, ADC_CH0, ADC_ALIGN_RIGHT);
 * 
 * // 2. Последовательное чтение 3 каналов
 * uint16_t values[3];
 * for(uint8_t i=0; i<3; i++) {
 *     ADMUX = (ADMUX & 0xF8) | i;    // Смена канала (0-2)
 *     values[i] = ADC_Read(i);       // Чтение с автозапуском
 * }
 * 
 * @note Для точных измерений:
 * - Дайте ИОН 2.56В время стабилизироваться (~1 мс)
 * - Избегайте переключения каналов при непрерывных измерениях
 * - Учитывайте входное сопротивление источника сигнала
 */
#pragma once


//////////////////////////////////////////////////////////////////////////
//  БАЗОВЫЕ НАСТРОЙКИ ПРОЕКТА
//////////////////////////////////////////////////////////////////////////

/// @def Частота процессора по умолчанию (16 МГц)
#ifndef F_CPU
#define F_CPU           16000000UL  // Добавлен UL для явного указания типа
#endif

/// @def Максимальная частота АЦП (рекомендуемая)
#define ADC_MAX_CLK     200000UL    // 200 кГц согласно datasheet ATmega32

#include <avr/io.h>
#include <util/delay.h>

// Проверка корректности настроек
#if (F_CPU / ADC_MAX_CLK) < 2
	#warning "Частота АЦП может быть слишком высокой для выбранного делителя!"
	#warning "The ADC frequency may be too high for the selected divider!"
#endif


//////////////////////////////////////////////////////////////////////////
//  НАСТРОЙКИ АЦП (ПЕРЕЧИСЛЕНИЯ И КОНСТАНТЫ)
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Состояние АЦП (включен/выключен)
 * @note Управляется битом ADEN в регистре ADCSRA
 */
typedef enum {
    ADC_DISABLED = 0,   ///< АЦП выключен (энергосбережение)
    ADC_ENABLED         ///< АЦП включен и готов к работе
} ADC_State;

/**
 * @brief Источник опорного напряжения
 * @note Влияет на регистр ADMUX (биты REFS0/REFS1)
 */
typedef enum {
    ADC_REF_AREF = 0,               ///< Внешний ИОН на выводе AREF
    ADC_REF_AVCC = (1 << REFS0),    ///< Напряжение питания AVcc (с конденсатором)
    ADC_REF_INTERNAL = (1 << REFS1) | (1 << REFS0)  ///< Внутренний 2.56В ИОН
} ADC_Reference;

/**
 * @brief Делитель частоты АЦП
 * @note Частота АЦП должна быть 50-200 кГц (рекомендуется 125 кГц)
 * @warning При F_CPU=16МГц используйте ADC_DIV128 (125 кГц)
 */
typedef enum {
    ADC_DIV2 = (1 << ADPS0),                          ///< F_CPU/2
    ADC_DIV4 = (1 << ADPS1),                          ///< F_CPU/4
    ADC_DIV8 = (1 << ADPS1) | (1 << ADPS0),           ///< F_CPU/8
    ADC_DIV16 = (1 << ADPS2),                         ///< F_CPU/16
    ADC_DIV32 = (1 << ADPS2) | (1 << ADPS0),          ///< F_CPU/32
    ADC_DIV64 = (1 << ADPS2) | (1 << ADPS1),          ///< F_CPU/64
    ADC_DIV128 = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0)  ///< F_CPU/128
} ADC_Prescaler;

/**
 * @brief Выбор аналогового канала
 * @note Соответствует выводам PORTA (ADC_CH0 = PA0, ..., ADC_CH7 = PA7)
 */
typedef enum {
    ADC_CH0 = 0,  ///< Канал 0 (PA0)
    ADC_CH1,      ///< Канал 1 (PA1)
    ADC_CH2,      ///< Канал 2 (PA2)
    ADC_CH3,      ///< Канал 3 (PA3)
    ADC_CH4,      ///< Канал 4 (PA4)
    ADC_CH5,      ///< Канал 5 (PA5)
    ADC_CH6,      ///< Канал 6 (PA6)
    ADC_CH7       ///< Канал 7 (PA7)
} ADC_Channel;

/**
 * @brief Выравнивание результата АЦП
 */
typedef enum {
    ADC_ALIGN_RIGHT = 0,       ///< Младшие биты в ADCL, старшие в ADCH
    ADC_ALIGN_LEFT = (1 << ADLAR)  ///< Старшие биты в ADCL, младшие в ADCH
} ADC_Alignment;




//////////////////////////////////////////////////////////////////////////
//  ОСНОВНЫЕ ФУНКЦИИ УПРАВЛЕНИЯ АЦП
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Полная инициализация АЦП
 * @param state Состояние (вкл/выкл)
 * @param ref Источник опорного напряжения
 * @param prescaler Делитель частоты (50-200 кГц)
 * @param channel Аналоговый канал (0-7)
 * @param align Выравнивание результата
 * @note Для внутреннего ИОН автоматически добавляется задержка 120 мкс
 * @warning Не использовать делитель меньше 2 (частота АЦП должна быть < 200 кГц)
 * 
 * @code
 * // Пример:
 * ADC_Init(ADC_ENABLED, ADC_REF_INTERNAL, ADC_DIV128, ADC_CH0, ADC_ALIGN_RIGHT);
 * @endcode
 */
void ADC_Init(ADC_State state, ADC_Reference ref, ADC_Prescaler prescaler, 
             ADC_Channel channel, ADC_Alignment align);

/**
 * @brief Базовая инициализация (только вкл/выкл)
 * @param state Состояние (ADC_DISABLED/ADC_ENABLED)
 * @note Остальные параметры остаются без изменений
 */
void ADC_Init(ADC_State state);

//////////////////////////////////////////////////////////////////////////
//  ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Включение АЦП
 * @note Аналог ADC_Init(ADC_ENABLED) без изменения других параметров
 */
void ADC_Enable(void);

/**
 * @brief Отключение АЦП (режим пониженного энергопотребления)
 */
void ADC_Disable(void);

/**
 * @brief Запуск преобразования
 * @note После вызова необходимо дождаться завершения через ADC_GetResult()
 *       или проверку флага ADIF
 */
void ADC_StartConversion(void);

/**
 * @brief Получение результата преобразования
 * @return 10-битное значение АЦП (0-1023)
 * @note Блокирующая функция - ожидает завершения текущего преобразования
 * @warning Перед вызовом убедитесь, что преобразование запущено
 */
uint16_t ADC_GetResult(void);

/**
 * @brief Чтение значения с указанного канала
 * @param ch Номер аналогового канала (0-7)
 * @return 10-битное значение АЦП
 * @note Автоматически запускает преобразование и ожидает результат
 * @warning Меняет текущий активный канал
 */
uint16_t ADC_Read(ADC_Channel ch);
