/**
 * @note        Комментарий сгенерирован нейросетью deepseek 19.08.25
 *
 * @file        UART.h
 * @brief       Реализация UART драйвера для AVR ATmega32
 * @details     Предоставляет полный набор функций для асинхронной последовательной связи
 *              с поддержкой кольцевых буферов и callback-функций.
 * 
 * @note        Особенности:
 *              - Поддержка скоростей до 115200 бод
 *              - Кольцевые буферы приема/передачи (64 байта)
 *              - Настраиваемые параметры связи (битность, четность, стоп-биты)
 *              - Режимы прерываний для приема/передачи
 *              - Callback-механизм для асинхронного приема
 * 
 * @warning     Ограничения:
 *              - Блокирующие функции приема (требуют обработки в основном цикле)
 *              - Ограниченный размер буферов (64 байта)
 *              - Нет поддержки аппаратного управления потоком
 * 
 * @attention   Для работы необходимо:
 *              - Подключение <avr/io.h> и <avr/interrupt.h>
 *              - Корректная настройка F_CPU
 *              - Включенные глобальные прерывания (sei())
 * 
 * @todo        Планируемые улучшения:
 *              - Реализация неблокирующих функций приема
 *              - Поддержка аппаратного управления потоком (RTS/CTS)
 *              - Расширяемые буферы динамического размера
 * 
 * @bug         Известные проблемы:
 *              - 
 * 
 * @author      Николай Куркин, deepseek
 * @date        2025-08-19
 * @version     1.0
 * 
 * @copyright   MIT License
 */

#pragma once
//////////////////////////////////////////////////////////////////////////
//  СИСТЕМНЫЕ ЗАГОЛОВОЧНЫЕ ФАЙЛЫ
//////////////////////////////////////////////////////////////////////////

#include <avr/io.h>          ///< Регистры ввода-вывода AVR
#include <avr/interrupt.h>   ///< Работа с прерываниями
#include <stddef.h>          ///< Стандартные определения размеров типов

//////////////////////////////////////////////////////////////////////////
//  ОСНОВНЫЕ НАСТРОЙКИ UART
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Базовая частота микроконтроллера (Гц)
 * @note Может быть переопределена перед включением этого файла
 * @warning Должна соответствовать реальной частоте CPU!
 * @value По умолчанию: 16 МГц (16000000UL)
 */
#ifndef F_CPU
#define F_CPU 16000000UL
#endif

/**
 * @brief Скорость передачи по умолчанию (бод)
 * @note Стандартные значения: 9600, 19200, 38400, 57600, 115200
 * @value По умолчанию: 9600
 */
#define BAUD 9600

/**
 * @brief Значение для регистра UBRR (USART Baud Rate Register)
 * @details Рассчитывается по формуле: 
 *          UBRR = (F_CPU / (16 * BAUD)) - 1
 * @note Для F_CPU=16МГц и BAUD=9600: 
 *       (16000000/(16*9600))-1 = 103.166 ? 103 (0x67)
 */
#define UBRR_VALUE ((F_CPU / (16UL * BAUD)) - 1)

/**
 * @brief Размер буфера приема (байт)
 * @note Рекомендуется степень двойки (64, 128, 256)
 * @warning Увеличивает потребление RAM
 */
#define UART_RX_BUFFER_SIZE 64

/**
 * @brief Размер буфера передачи (байт)
 * @note Рекомендуется степень двойки (64, 128, 256)
 * @warning Увеличивает потребление RAM
 */
#define UART_TX_BUFFER_SIZE 64

//////////////////////////////////////////////////////////////////////////
//  КОНФИГУРАЦИЯ UART (ПЕРЕЧИСЛЕНИЯ)
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Состояние UART (вкл/выкл)
 * @note Управляется битами RXEN/TXEN в регистре UCSRB
 */
typedef enum {
    UART_DISABLED = 0,  ///< UART выключен (энергосбережение)
    UART_ENABLED         ///< UART включен и готов к работе
} UART_State;

/**
 * @brief Режимы битности данных
 * @note Для 9-битного режима требуется дополнительно установить бит UCSZ2
 */
typedef enum {
    UART_5_BITS = 0,  ///< 5 бит данных (редко используется)
    UART_6_BITS,      ///< 6 бит данных
    UART_7_BITS,      ///< 7 бит данных (для ASCII)
    UART_8_BITS,      ///< 8 бит данных (стандартный режим)
    UART_9_BITS = 7   ///< 9 бит данных (особый режим)
} UART_DataBits;

/**
 * @brief Количество стоп-битов
 * @note Большинство устройств используют 1 стоп-бит
 */
typedef enum {
    UART_1_STOP_BIT = 0,  ///< 1 стоп-бит (стандарт)
    UART_2_STOP_BITS       ///< 2 стоп-бита (для длинных линий)
} UART_StopBits;

/**
 * @brief Режимы контроля четности
 * @note Используется для обнаружения ошибок передачи
 */
typedef enum {
    UART_PARITY_NONE = 0,  ///< Без контроля четности
    UART_PARITY_EVEN = 2,   ///< Четный паритет
    UART_PARITY_ODD = 3     ///< Нечетный паритет
} UART_Parity;

/**
 * @brief Режимы прерываний UART
 * @note Позволяют обрабатывать события в фоновом режиме
 */
typedef enum {
    UART_INTERRUPT_DISABLED = 0,    ///< Прерывания отключены
    UART_INTERRUPT_RX_ENABLED,      ///< Прерывание по приему
    UART_INTERRUPT_TX_ENABLED,      ///< Прерывание по готовности передатчика
    UART_INTERRUPT_BOTH_ENABLED     ///< Оба прерывания включены
} UART_Interrupt;

//////////////////////////////////////////////////////////////////////////
//  CALLBACK-МЕХАНИЗМ ДЛЯ АСИНХРОННОГО ПРИЕМА
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Тип callback-функции для обработки принятых данных
 * @param[in] c Принятый символ (1 байт данных)
 * @note Функция вызывается из прерывания при получении каждого символа
 * @warning Должна быть максимально краткой (не блокировать прерывания)
 * @example 
 * void my_callback(char data) {
 *     // Обработка полученного символа
 * }
 */
typedef void (*UART_RxCallback)(char c);

//////////////////////////////////////////////////////////////////////////
//  ОСНОВНОЙ ИНТЕРФЕЙС UART API
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Расширенная инициализация UART
 * @param[in] state Состояние (UART_ENABLED/UART_DISABLED)
 * @param[in] dataBits Количество бит данных (5-9 бит)
 * @param[in] stopBits Количество стоп-битов (1 или 2)
 * @param[in] parity Контроль четности (NONE/EVEN/ODD)
 * @param[in] interrupt Режим прерываний (RX/TX/BOTH)
 * @note Для 9-битного режима автоматически устанавливается бит UCSZ2
 * @warning Неправильные настройки могут привести к ошибкам связи!
 */
void UART_Init(UART_State state, UART_DataBits dataBits, 
              UART_StopBits stopBits, UART_Parity parity, 
              UART_Interrupt interrupt);

/**
 * @brief Базовая инициализация UART с настройками по умолчанию
 * @param[in] state Состояние (UART_ENABLED/UART_DISABLED)
 * @details Используются параметры:
 * - 8 бит данных
 * - 1 стоп-бит
 * - Без контроля четности
 * - Прерывания приема включены
 * - Скорость 9600 бод
 */
void UART_Init(UART_State state);

/**
 * @brief Включение приемопередатчика UART
 * @note Активирует биты RXEN и TXEN в регистре UCSRB
 */
void UART_Enable(void);

/**
 * @brief Выключение приемопередатчика UART
 * @note Деактивирует биты RXEN и TXEN в регистре UCSRB
 * @warning Останавливает все текущие передачи
 */
void UART_Disable(void);

/**
 * @brief Установка скорости передачи (бодрейт)
 * @param[in] baud Скорость в бодах (300-115200)
 * @note Пересчитывает значение UBRR по формуле:
 *       UBRR = (F_CPU / (16 * baud)) - 1
 * @warning Не меняет текущие настройки формата кадра
 */
void UART_SetBaudRate(uint32_t baud);

//////////////////////////////////////////////////////////////////////////
//  ФУНКЦИИ ПЕРЕДАЧИ ДАННЫХ
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Синхронная передача одного символа
 * @param[in] c Символ для передачи (1 байт)
 * @note Блокирует выполнение до готовности передатчика
 * @warning Для 9-битного режима требует отдельной обработки
 */
void UART_SendChar(char c);

/**
 * @brief Передача нуль-терминированной строки
 * @param[in] str Указатель на строку (завершается '\0')
 * @note Последовательно передает все символы строки
 * @example UART_SendString("Hello\r\n");
 */
void UART_SendString(const char *str);

/**
 * @brief Передача бинарного массива данных
 * @param[in] buffer Указатель на буфер данных
 * @param[in] length Количество байт для передачи
 * @note Безопасно работает с бинарными данными (включая нулевые байты)
 */
void UART_SendBuffer(const uint8_t *buffer, uint16_t length);

//////////////////////////////////////////////////////////////////////////
//  ФУНКЦИИ ПРИЕМА ДАННЫХ
//////////////////////////////////////////////////////////////////////////

/**
 * @brief Синхронный прием одного символа
 * @return Принятый символ (1 байт)
 * @note Блокирует выполнение до получения данных
 * @warning Для 9-битного режима требует отдельной обработки
 */
char UART_ReceiveChar(void);

/**
 * @brief Прием массива данных в буфер
 * @param[out] buffer Буфер для записи принятых данных
 * @param[in] length Максимальное количество байт для приема
 * @return Количество фактически принятых байт
 * @note Читает все доступные данные (но не более length байт)
 */
uint8_t UART_ReceiveBuffer(uint8_t *buffer, uint16_t length);

/**
 * @brief Проверка наличия данных в буфере приема
 * @return Количество доступных для чтения байт
 * @note Неблокирующая функция
 */
uint8_t UART_DataAvailable(void);

/**
 * @brief Очистка буфера приема
 * @note Сбрасывает индексы головы и хвоста буфера
 * @warning Удаляет все непрочитанные данные!
 */
void UART_FlushRxBuffer(void);

/**
 * @brief Установка callback-функции для асинхронного приема
 * @param[in] callback Функция обратного вызова (NULL для отключения)
 * @note При установке callback стандартный буфер не используется
 * @warning Callback выполняется в контексте прерывания!
 */
void UART_SetRxCallback(UART_RxCallback callback);