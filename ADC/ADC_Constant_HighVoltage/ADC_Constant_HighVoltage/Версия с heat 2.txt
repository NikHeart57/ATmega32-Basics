/* 
 * Пример DC-DC бустера на 100В, который сам себя регулирует
 * Пин АЦП - PA7(ADC7). К HV выводу бустера подключен делитель напряжения на 101 (R1 = 1МОм, R2 = 10кОм, K = 101)
 * АЦП смотрит напряжение на делителе, и в соответствии с ним меняет скважность ШИМ бустера (OCR1B)
 * за счет чего меняется напряжение бустера.
 * Gин PD4 - PWM, пины PC2..4 - лампочки для индикации состояния АЦП.
 * AREF, AVCC, ADC7 - конденсаторами подключены к земле, AVCC - подключена к VCC через индукцию
 */

#define F_CPU 7372800
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h> 
#include <stdio.h>
#include <stdlib.h>

void setup()
{
	DDRC = 0b00011100;   // Выходы для желт.(PC2), зел.(PC3), красн.(PC4) лампочек (1)
	DDRD = 0b00010000;   // PD4 - PWM
	DDRA = 0b00000000;   // Все входы  (0)
	
	
	ADCSRA |= (1 << ADEN);                                // Разрешаем работу АЦП (1)
	ADCSRA |= (1 << ADSC);                                // Запуск АЦП (1)
	ADCSRA |= (1 << ADPS2)|(1 << ADPS1)|(1 << ADPS0);     // Задаю делитель N для определения частоты дискретизации f_ацп = f_цпу / N;
	                                                      // при ADPS0..2 = 111       => f_ацп = 7372800 / 128 = 57600Гц
	ADMUX  |= (1 << REFS1)|(1 << REFS0);                  // Задаю ИОН, REFS0..1 = 11 => внутренний ИОН, U_ион = 2,56В
	ADMUX  |= (0 << ADLAR);                               // Правосторонее выравнивание ADLAR = 0; ADCH, ADCL
	ADMUX  |= (0 << MUX4)|(0 << MUX3)|(1 << MUX2)|(1 << MUX1)|(1 << MUX0);  // Выбор пина АЦП; MX0..4 = 00111 => ADC7(PA7);
	
	
	sei();
	TCCR1A |= (0 << COM1A1)|(0 << COM1A0)|(1 << COM1B1)|(0 << COM1B0)|(0 << FOC1A)|(0 << FOC1B)|(0 << WGM11)|(0 << WGM10);
	TCCR1B |= (0 << ICNC1) |(0 << ICES1) |(1 << WGM13) |(0 << WGM12) |(0 << CS12) |(0 << CS11) |(1 << CS10);
	ICR1 = 200;   // Верхнее значение, до которого идет счет
	OCR1B = 195;    // Регистр сравнения, при совпадении с которым меняется состояние вывода OC1B
	
}


int main(void)
{
	setup();
	
	int heatL = 0;
	int heatH = 0;
	
	while (1)
	{
		// Рестарт АЦП
		if (ADCSRA & (1 << ADIF))        // Если флаг ADIF = 0 (т.е.ADCSRA&(1<<ADIF)=true) значит преобразование выполнилось
		{
			ADCSRA |= (1 << ADIF);       // Установка флага ADIF, чтобы позволить дальнейшую работу АЦП
			ADCSRA |= (1 << ADSC);       // Запуск АЦП
		}
		
		// Логика АЦП
		if (ADC < 380)                                 // Если U_in < 0,98В (Uhv < 99В, ADC < 392) - загорится желтая лампа (PC2)
		{
			PORTC = (1 << PC2)|(0 << PC3)|(0 << PC4);
			if (OCR1B < (ICR1 - 2) && heatL == 0)
			{
				OCR1B++;
				heatL = 400;
			}
			heatL--;
		}
		else if	(ADC >= 380 && ADC <= 420)	           // Если 0,98В <= U_in >= 1В  - загорится зеленая лампа (PC3)
		{
			PORTC = (0 << PC2)|(1 << PC3)|(0 << PC4);
			heatL = 2;
			heatH = 2;
		}
		else                                           // Если U_in > 1В (Uhv > 101В, ADC < 400) - загорится красная лампа (PC4)
		{
			PORTC = (0 << PC2)|(0 << PC3)|(1 << PC4);
			if (OCR1B > (ICR1 / 2) && heatH == 0)
			{
				OCR1B--;
				heatH = 400;
			}
			heatH--;
		}					
	}
}

